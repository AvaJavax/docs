1. 索引：索引是为了加速对表中数据行的检索而创建的一种分散存储的数据结构

2. 索引的作用
a. 索引能极大的减少存储引擎需要扫描的数据量
b. 索引可以把随机IO变成顺序IO
c. 索引可以帮助我们在进行分组、排序等操作时，避免使用临时表

3. 正确的创建合适的索引是提升数据库查询性能的基础

4. 常见的索引类型--哈希表
哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即 value。哈希的思路很简单，把值放在数组里，
用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。
处理这种情况的一种方法是，拉出一个链表。但是哈希表不是有序的，索引在区间查询的时候是很慢的。所以，哈希表这种结构适用于只有等值查询的场景，
比如 Memcached 或 Redis 及其他一些 NoSQL 引擎。

5. 常见的索引类型--有序数组
有序数组在等值查询和范围查询场景中的性能就都非常优秀，单值查询时，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。区间查询时，遍历循环时，
从满足条件的开始获取，到不满足的条件，退出循环即可，如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，
你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。

6. 常见的索引类型--二叉搜索树
二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查具体值的话，这个时间复杂度是 O(log(N))。当然为了维持 O(log(N)) 的查询复杂度，
你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。
二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。
一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能
需要 20 个 10 ms 的时间，这个查询可真够慢的。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。
这里，“N 叉”树中的“N”取决于数据块的大小。N叉树典型的实现中就有B-Tree，B树有好几种，B-Tree，B+Tree，B*Tree等。

7. Mysql索引是什么类型的数据结构？B+Tree
7.1 B-Tree 和 B+Tree 的区别
a. B+节点关键字搜索采用闭合区间
b. B+非叶节点不保存数据相关信息，只保存关键字和子节点的引用
c. B+关键字对应的数据保存在叶子节点中
d. B+叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系
7.2 索引选择B+Tree的原因：
a. B+树是B-树的变种（PLUS版）多路绝对平衡查找树，他拥有B-树的优势
b. B+树扫库、表能力更强
c. B+树的磁盘读写能力更强
d. B+树的排序能力更强
e. B+树的查询效率更加稳定（仁者见仁、智者见智）

8. Myisam是三个文件：table.frm、table.MYD、table.MYI ；Innodb是两个文件：table.frm、table.ibd

9. 索引特性--回表
select * from T where k between 3 and 5
我们一起看看这条 SQL 查询语句的执行流程：在 k 索引树上找到 k=3 的记录，取得 ID=300；再到 ID 索引树查到 ID=300 对应的 R3；
在 k 索引树取下一个值 k=5，取得 ID=500；再回到 ID 索引树查到 ID=500 对应的 R4；在 k 索引树取下一个值 k=6，不满足条件，循环结束。
在这个过程中，回到主键索引树搜索的过程，称为回表。

10. 索引特性--覆盖索引
由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？
如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。
也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。
由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

11. 索引特性--最左前缀
疑问：如果为每一种查询都设计一个索引，索引是不是太多了。B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。
索引项是按照索引定义里面出现的字段顺序排序的。当逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。
如果要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是"where name like '张%'"。这时也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。
可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。
基于上面对最左前缀索引的说明，讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。
这里评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。
因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

12. 索引特性--索引下推
之前说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，那些不符合最左前缀的部分，会怎么样呢？
还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：
select * from tuser where name like '张%' and age=10 and ismale=1;
现已知前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。
然后呢？当然是判断其他条件是否满足。在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。
而 MySQL 5.6 引入的索引下推优化（index condition pushdown）， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

13. 索引特性--列的离散性
列的离散性：count(distinct col):count(col)
比值越大，离散型越好；离散性越高，选择性就越好

14. 索引特性总结：
a. 索引列的数据长度能少则少
b. 索引一定不是越多越好，越全越好，一定是建合适的
c. 匹配列前缀可用到索引如 like 9999%，而like %9999%、like %9999用不到索引
d. where 条件中 not in 和 <> 操作无法使用索引
e. 匹配范围值，order by 也可用到索引
f. 多列指定列查询，只返回自己想要的数据列，少用select *
g. 联合索引中如果不是按照索引最左列开始查找，无法使用索引
h. 联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引
i. 联合索引中如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引

15.
【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。
【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。
【推荐】利用覆盖索引来进行查询操作，避免回表。
说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。
正例：能够建立索引的种类分为主键索引，唯一索引，普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果，extra 列会出现: using index。
【推荐】建组合索引的时候，区分度最高的在最左边。
正例：有 where a=? and b=?，如果 a 列几乎接近于唯一值，那么只需要单建 idx_a 索引即可。
说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c>? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c。

16.
问题1：通常一棵B+树可以存放多少行数据？
我们都知道计算机在存储数据的时候，有最小存储单元，这就好比我们今天进行现金的流通最小单位是一毛。在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，
而文件系统（例如XFS/EXT4）的最小单元是块，一个块的大小是4k，而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。
磁盘扇区、文件系统、InnoDB存储引擎都有各自的最小存储单元。

这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。这里假设一行记录的数据大小为1k，
那么单个叶子节点（页）中的记录数=16K/1K=16。那么现在我们需要计算出非叶子节点能存放多少指针，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，
这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。
根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170*1170*16=21902400条这样的记录。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。
在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。

怎么得到InnoDB主键索引B+树的高度？
SELECT b.name, a.name, index_id, type, a.space, a.PAGE_NO FROM 
information_schema.INNODB_SYS_INDEXES a, 
information_schema.INNODB_SYS_TABLES b WHERE a.table_id = b.table_id AND a.space <> 0;

问题2：DBA 小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：
CREATE TABLE `geek` (
`a` int(11) NOT NULL,
`b` int(11) NOT NULL,
`c` int(11) NOT NULL,
`d` int(11) NOT NULL,
PRIMARY KEY (`a`,`b`),
KEY `c` (`c`),
KEY `ca` (`c`,`a`),
KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。学习相关知识后小吕又纳闷了，既然主键包含了 a、b 这两个字段，
那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”、“cb”这两个索引？同事告诉他，是因为他们的业务里面有这样的两种语句：
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
因此问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？

表记录
-a--|-b--|-c--|-d--
1 2 3 d
1 3 2 d
1 4 3 d
2 1 3 d
2 2 2 d
2 3 4 d
主键 a，b 的聚簇索引组织顺序相当于 order by a,b ，也就是先按 a 排序，再按 b 排序，c 无序。

索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键。
-c--|-a--|-主键部分b--（注意，这里不是 ab，而是只有 b）
2 1 3
2 2 2
3 1 2
3 1 4
3 2 1
4 2 3
这个跟索引c的数据是一模一样的。

索引 cb 的组织是先按 c 排序，再按 b 排序，同时记录主键。
-c--|-b--|-主键部分a--（同上）
2 2 2
2 3 1
3 1 2
3 2 1
3 4 1
4 3 2
所以，结论是 ca 可以去掉，cb 需要保留。

问题3：慢SQL如何统计
show variables like 'slow_query_log'
set global slow_query_log = on
set global slow_query_log_file = '/var/sqlslow.log'
set global log_queries_not_using_indexes = on 
set global long_query_time = 0.1（秒）

Time：日志记录的时间
User@Host：执行的用户及主机
Query_time：查询耗费时间 Lock_time 锁表时间 Rows_sent 发送给请求方的记录条数 Rows_examined 语句扫描的记录条数
SET timestamp：语句执行的时间点
select....：执行的具体语句

问题4：
a. select count(*) from tradelog where month(t_modified)=7;
t_modified是有索引的，此时是否生效？
b. select * from tradelog where tradeid=110717;
tradeid是主键，且是varchar类型，这种情况下会走索引吗？
select * from tradelog where tradeid="110717";
tradeid是主键，且是Long类型，这种情况下会走索引吗？
c. 两张表，交易日志表（tradelog）和交易详情表（trade_detail）都有trade_Id字段，且都有索引，但是在关联查询的过程中，
如果要查询 id=2 的交易的所有操作步骤信息，SQL 语句可以这么写：
select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2;
但是发现并没有走索引，可能的原因有哪些？

a. 对索引字段做函数操作，优化器会放弃走树搜索功能。
b. 在 MySQL 中，字符串和数字做比较的话，是将字符串转换成数字。
select * from tradelog where CAST(tradid AS signed int) = 110717;
c. select * from trade_detail where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; 
这就再次触发了上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。
