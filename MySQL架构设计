大体来说，MySQL 可以分为 Server 层和存储引
擎层两部分。
Server 层：
包括连接器、查询缓存、分析器、优化器、执行
器等，涵盖 MySQL 的大多数核心服务功能，以及
所有的内置函数（如日期、时间、数学和加密函
数等），所有跨存储引擎的功能都在这一层实现，
比如存储过程、触发器、视图等。
存储引擎层：
而存储引擎层负责数据的存储和提取。其架构模
式是插件式的，支持 InnoDB、MyISAM、
Memory 等多个存储引擎。现在最常用的存储引
擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为
了默认存储引擎。
2.1、连接器：
第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客
户端建立连接、获取权限、维持和管理连接。
如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连
接里面的权限判断逻辑，都将依赖于此时读到的权限。
这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了
修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新
的权限设置。
客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数
wait_timeout 控制的，默认值是 8 小时。
查询缓存:
可以通过show variables like '%query_cache%' 来判断是否开启查询缓存，默认是关闭
的；
query_cache_type: 是否开启缓存功能，取值为ON, OFF, DEMAND，默认值为OFF
- 值为OFF或0时，查询缓存功能关闭；
- 值为ON或1时，查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否
则，不予缓存，显式指定SQL_NO_CACHE，不予缓存；
- 值为DEMAND或2时，查询缓存功能按需进行，显式指定SQL_CACHE的
SELECT语句才会缓存；其它均不予缓存。
强烈建议：关闭查询缓存，因为查询缓存的功能非常鸡肋，因为查询缓存的失效非常
频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你
费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据
库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才
会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。
需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开
始彻底没有这个功能了。
分析器：
词法分析：MySQL 从你输入的"select"这个关键字识别出来，这是一个查询语句。它
也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。
语法分析：做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法
分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。
优化器：
经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的
处理。
优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关
联（join）的时候，决定各个表的连接顺序
执行器:
MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执
行器阶段，开始执行语句。
开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会
返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返
回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。
如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使
用这个引擎提供的接口。
mysql> select * from T where ID=10；
比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：
调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如
果是则将这行存在结果集中；
调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
