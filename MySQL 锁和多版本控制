SQL92 ANSI/ISO标准：
http://www.contrib.andrew.cmu.edu/-shandow/sql/sql1992.txt
Read Uncommitted（未提交读） --未解决并发问题
事务未提交对其他事务也是可见的，脏读（dirty read）
Read Committed（提交读） --解决脏读问题
一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读（nonrepeatable read)
Repeatable Read (可重复读)  --解决不可重复读问题
在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未定义解决幻读的何题
Serializable（串行化） --解决所有问题
最高的隔离级别，通过强制事务的串行执行

读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
读已提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到
的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可
见的。
串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读
锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才
能继续执行。
在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在
“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间
都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行
的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的
最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行
访问。

事务隔离级别				         脏读	    不可重复读	   幻读
未提交读(Read Uncommitted)	可能	    可能		     可能
已提交读(Read Committed)	  不可能	   可能		      可能
可重复读(Repeatable Read)	  不可能	   不可能		   对InnoDB不可能
串行化(Serializable)		     不可能	  不可能		    不可能
并发能力依次下降
隔离级别到底如何实现的呢？锁、MVCC

MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类
全局锁：
顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，
命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，
可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删
改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文
本。那为什么要加锁，不加锁又有什么后果？
不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。
说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到
一致性视图的，对吧？
官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 
的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，
这个过程中数据是可以正常更新的。
有了这个功能，为什么还需要 FTWRL 呢？一致性读是好，但前提是引擎要支持这个隔
离级别。比如，对于 MyISAM 这种不支持事务的引擎。

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
表锁：
表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释
放锁，也可以在客户端断开的时候自动释放。
MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写
的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一
个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯
定是不行的。
因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 
读锁；当要对表做结构变更操作的时候，加 MDL 写锁。
1、读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
2、读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因
此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM 引擎就不支持
行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执
行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。
我先给你举个例子。在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。
这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候
释放。你可以验证一下：实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行
commit 之后，事务 B 才能继续执行。

知道了这个答案，你一定知道了事务A 持有的两个记录的
行锁，都是在 commit 的时候才释放的。
也就是说 在 InnoDB 事务中，行锁是在需要的时候才加上
的，但并不是不需要了就立刻释放，而是要等到事务结束
时才释放。这个就是两阶段锁协议。
知道了这个设定，对我们使用事务有什么帮助呢？那就是，
如果你的事务中需要锁多个行，要把最可能造成锁冲突、
最可能影响并发度的锁尽量往后放

https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html
MySQL InnoDB锁类型
共享锁（行锁）：Shared Locks
排它锁（行锁）：Exclusive Locks
意向锁共享锁（表锁）：Intention Shared Locks
意向锁排它锁（表锁）：Intention Exclusive Locks
自增锁：AUTO-INC Locks
行锁的算法
记录锁Record Locks
间隙锁Gap Locks
临键锁Next-key Locks

共享锁(Shared Locks) vs 排它锁(Exclusive Locks
共享锁:
又称为读锁，简称s锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，
都能访问到数据，但是只能读不能修改;
加锁释锁方式:
select * from users WHERE id=1 LOCK IN SHARE MODE
commit/rollback
排他锁：
又称为写锁，简称X锁，排他锁不能与其他锁并存，如一个事务获取了一个数据行的排他
锁，其他事务就不能再获取该行的锁(共享锁、排他锁)，只有该获取了排他锁的事务是可以对
数据行进行读取和修改，（其他事务要读取数据可来自于快照）
加锁释锁方式：
delete / update / insert 默认加上X锁
SELECT * FROM table name WHERE ... FOR UPDATE
commit/rollback

意向锁
innodb的意向锁主要用户多粒度的锁并存的情况。比如事务A要在一个表上加S锁，如果表中的
一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志
的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来
表示其所属行的加锁情况，这就引出了“意向锁”的概念。
举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加
表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，
那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意
向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须
逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被
锁了就行了。
意向锁(IS、IX)是InnoDB数据操作之前自动加的，不需要用户干预
意义：
当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能
启用表锁
说白了意向锁的主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某
一行上持有了锁，或者准备去持有锁”

自增锁AUTO-INC Locks
针对自增列自增长的一个特殊的表级别锁
show variables like 'innodb_autoinc_lock_mode';
默认取值1，代表连续，事务未提交ID永久丢失
CREATE TABLE `t` (
`id` int(11) NOT NULL,
`c` int(11) DEFAULT NULL,
`d` int(11) DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `c` (`c`)
) ENGINE=InnoDB;
insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);

产生幻读的原因是:行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解
决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。
顾名思义，间隙锁，锁的就是两个值之间的空隙。表 t1，初始化插入了 6 个记录，这就产生了 7 个间隙。
这样，当你执行 select * from t where d=5 for update 的时候，就不止是给数据库中已有的 6 个记录加上
了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。
也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。
现在你知道了，数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟
我们之前碰到过的锁都不太一样。
和行锁冲突的是另一个行锁，但是间隙锁不一样，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个
记录”这个操作。间隙锁之间都不存在冲突关系。 Gap只在RR事务隔离级别存在。
这里 session B 并不会被堵住。因为表 t 里并没有 c=7 这
个记录，因此 session A 加的是间隙锁 (5,10)。而 session 
B 也是在这个间隙加的间隙锁。它们有共同的目标，即：
保护这个间隙，不允许插入值。但，它们之间是不冲突的。

间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是
说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有
记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、
(10,15]、(15,20]、(20, 25]、(25, +supremum]。
间隙锁都是前开后开区间的锁。
你可能会问说，这个 supremum 从哪儿来的呢？
这是因为 +∞是开区间。实现上，InnoDB 给每个索引加了一个不存在的最大值
supremum，这样才符合我们前面说的“都是前开后闭区间”。

前面介绍了间隙锁和 next-key lock 的概念，但是并没有说明加锁规则。间隙锁的概念
理解起来确实有点儿难，尤其在配合上行锁以后，很容易在判断是否会出现锁等待的问
题上犯错。
先说总结：加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。
原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后
闭区间。
原则 2：查找过程中访问到的对象才会加锁。
优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-
key lock 退化为间隙锁。
一个 “bug”：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

案例一：等值查询间隙锁
第一个例子是关于等值条件操作间隙：
由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：
根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；
同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-
key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。
所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session 
C 修改 id=10 这行是可以的。

案例二：非唯一索引等值锁
看到这个例子，你是不是有一种“该锁的不锁，不该锁的乱锁”的感觉？我们来分析一下吧。
这里 session A 要给索引 c 上 c=5 的这一行加上读锁。
根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。
要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则
2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。
但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。
根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任
何锁，这就是为什么 session B 的 update 语句可以执行完成。
但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。
需要注意，在这个例子中，lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，
系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。
这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据
被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改
成 select d from t where c=5 lock in share mode。你可以自己验证一下效果。

案例三：主键索引范围锁
select * from t where id=10 for update;
select * from t where id>=10 and id<11 for update;
现在我们就用前面提到的加锁规则，来分析一下 session A 会加什么锁呢？
开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行
锁，只加了 id=10 这一行的行锁。
范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。
所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。这样，session B 和 session C 的结果
你就能理解了。
这里你需要注意一点，首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，
用的是范围查询判断。

案例四：非唯一索引范围锁
这次 session A 用字段 c 来判断，加锁规则跟案例三唯一的不同是：在第一次
用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于
索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终
sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。
所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住
了。
这里需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到 c=15，才
知道不需要继续往后找了。

案例五：唯一索引范围锁 bug
session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所
以循环判断到 id=15 这一行就应该停止了。
但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的
(15,20] 这个 next-key lock 也会被锁上。
所以你看到了，session B 要更新 id=20 这一行，是会被锁住的。同样地，session C 要插入 id=16 的一行，也会被锁住。
照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15，就可以确定不用往后再找了。但实现上还是
这么做了，因此作者为这是个 bug。
也有人也曾找社区的专家讨论过，官方 bug 系统上也有提到，但是并未被 verified。所以，认为这是 bug 这个事儿，也只能
算有些人的一家之言。
由于是 order by c desc，第一个要定位的是索引 c 上“最右边的”c=20 的行，所以会加上间隙锁 (20,25) 
和 next-key lock (15,20]。
在索引 c 上向左遍历，要扫描到 c=10 才停下来，所以 next-key lock 会加到 (5,10]，这正是阻塞 session 
B 的 insert 语句的原因。
在扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 select *，所以会在主键 id 上加三个行锁。
因此，session A 的 select 语句锁的范围就是：
索引 c 上 (5, 25)；
主键索引上 id=15、20 两个行锁。
这里，我再啰嗦下，每次加锁都会说明是加在“哪个索引上”的。因为，锁就是加在索引上的，这是
InnoDB 的一个基础设定，需要你在分析问题的时候要一直记得。

多版本控制
InnoDB存储引擎在数据库每行数据的后面添加了三个字段
•6字节的事务ID(DB_TRX_ID)字段: 用来标识最近一次对本行记录做修改(insert|update)
的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。
至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表
示为deleted, 并非真正删除。
•7字节的回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo 
log record (撤销日志记录记录)。
如果一行记录被更新, 则 undo log record 包含 '重建该行记录被更新之前内容' 所必须的
信息。
•6字节的DB_ROW_ID字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产
生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。
结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中没有主键或合适的唯一索引, 也
就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用
DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引
中也就不会包含 DB_ROW_ID 了 。

而 V1、V2、V3 并不是物理
上真实存在的，而是每次需要的
时候根据当前版本和 undo log 计
算出来的。比如，需要 V2 的时候，
就是通过 V4 依次执行 U3、U2 
算出来。

总结：
1、MySQL的架构
2、MySQL的引擎
3、索引B+Tree
4、锁和多版本控制解决了InnoDB在可重复读的情况下，幻读的问题
